# Основа

>Go — компилируемый многопоточный язык программирования, разработанный внутри компании Google. Разработка Go началась в сентябре 2007 года, его непосредственным проектированием занимались `Роберт Гризмер, Роб Пайк и Кен Томпсон`

```php
package main // название исполняемого файла/пакета

import "fmt" // импорты

func main() {       // точка входа
    var user string // инициализация переменной
    userName := "alisher" // можно и так (bool, float, int точно так создаются)
    array := [...]int{1,2,3}  // [длина массив]тип значание{значение}
}
```

##### slice
```php
slice := []int{1,2,3} // []тип значание{значение}
под капотом слайс сожержит массив,  именно ссылку/указатель на массива.
отличия от массива не указываем длину слайса, ожной строны это плохо. допустим у слайса капасити 4, и когда мы добавляем 5 элемент капасити = 8, длина массива = 5 и создается новый массив + ссылка/указатель у слайса менятся а старый массив так и остается в памяти.
slice := make([]int, 15, 15) // можно этого избежать, если знаем длину (по возможности аллоцировать память)

нельзя проверять слайс на nil, лучше len(slice) == 0

на важно как мы передаем слайс, под капотом передается по ссылке

slice := []int{0,1,2}
a := slice[:1]

func(slice []int) {
    slice[0] = 1
}

в конце a[0] = 1


если хотим изменить переданный слайс, создаем его копию
```

##### итерация массива
```php
for i := range array {
    if (i == 2) {
        array[i] = 0
    }
    fmt.Println(array[i])
}
```

##### switch

```php
switch array[1] {    // базовый 
case 'val':
    fmt.Println(array[1], "found")
default:
    fmt.Println("not found")
}


MyLoop:
    for i := range array {
        switch {
        case i == 1:
            fmt.Println(array[i], "Break")
            break  MyLoop // выходим из цикла
        default:
            fmt.Println(array[i])
        }
    }
```

##### map/hashtable

> хэш-таблица — это контейнер, который используют, если хотят быстро выполнять операции вставки/удаления/нахождения.

| <b>операция</b> | <b>insert</b> | <b>remove</b> | <b>find</b> |   
|-----------------|---------------|---------------|-------------|
| array           | O(n)          | O(n)          | O(n)        |  
| list            | O(1)          | O(1)          | O(n)        |  
| бинарное дерево | O(logN)       | O(logN)       | O(logN)     | 
| `хэш-таблица`   | O(1)          | O(1)          | O(1)        |

> из этой таблицы очень хорошо понятно, почему же стоит использовать хэш-таблицы. но тогда возникает противоположный вопрос: почему же тогда ими не пользуются постоянно?
ответ очень прост: как и всегда, невозможно получить все сразу, а именно: и скорость, и память. хэш-таблицы тяжеловесные, и, хоть они и быстро отвечают на вопросы основных операций, пользоваться ими все время очень затратно.

> хэш-функция это преобразование к ключе и на выходе получаем номер бакета. 

`требования к бакету (bucket = hash(key))`
* равномерность - все записи должны равномерно распределины
* быстрота - время выполнения == O(1)
* детерминированность - для одного и того же ключа должен возвращать один и тот же номер бакета
* криптоустойчивость
##### map/hashtable

##### linked list
> **связные списки** — это линейно сгруппированные наборы данных. Они состоят из узлов, в которых содержатся данные и указатели. мы сфокусируемся на односвязных списках, узлы которых содержат данные и указатель на следующий узел. однако следует иметь в виду, что существуют также двусвязные и кольцевые связные списки.

> * **указатель** содержит адрес участка памяти, хранящего определённые данные (для указателей также допустимо нулевое значение)
> * **ссылка**, в отличие от указателя, всегда должна указывать на определённый адрес

##### интерфейсы
>  **интерфейс** - это набор методов, представляющих стандартное поведение для различных типов данных. c помощью интерфейсов можно организовывать разные группы методов. он определяет и описывает конкретные методы, которые должны быть у какого-то другого типа.

* чем меньше методов - тем лучше
* если метод один, его имя образовано от имени интерфейса (метод = глагол)

>  интерфейс может содержать в себе несколько интерфейсов